#include <vector>
using namespace std;
// 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。
// 返回仅包含 1 的最长（连续）子数组的长度。
// 示例 1：
// 输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
// 输出：6
// 解释： 
// [1,1,1,0,0,1,1,1,1,1,1]
// 粗体数字从 0 翻转到 1，最长的子数组长度为 6。
// 示例 2：
// 输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
// 输出：10
// 解释：
// [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
// 粗体数字从 0 翻转到 1，最长的子数组长度为 10。
class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
        int len = A.size(), ans = 0;
        int l = 0, r = 0, sums = 0;     // 左边界l，右边界r，用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
        while(r < len) {    // 循环条件
            sums += A[r];   // 增加当前右边指针的数字/字符的求和/计数
            while ((r - l + 1 - sums) > K) {    // 当不满足窗口内条件时，此时需要移动左指针
                sums -= A[l];   // 移动左指针前需要从sum中减去l位置自负的求和/计数
                l++;    // 移动左边界
            }
            ans = max(ans, r - l + 1);      // 更新最大值
            r++;    
        }
        return ans;
    }
};